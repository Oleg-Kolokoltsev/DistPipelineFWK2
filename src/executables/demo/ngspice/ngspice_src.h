//
// Created by morrigan on 4/5/19.
//

#ifndef DISTPIPELINEFWK_NGSPICE_SRC_H
#define DISTPIPELINEFWK_NGSPICE_SRC_H

#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <complex>
#include <atomic>
#include <mutex>

#include <ngspice/sharedspice.h>

#include "base_source.hpp"

// TODO: Check if it is possible to have multiply instances of the initialized
// TODO: NgSpice or this source should prevent creation of multiply objects of itself
// TODO: (not a singleton pattern!)

struct NgSpiceOutPkt : public BaseMessage{
    // empty constructor
    NgSpiceOutPkt(){}

    // copy constructor
    NgSpiceOutPkt(const NgSpiceOutPkt& pkt) :
        BaseMessage(pkt),
        vectors(pkt.vectors),
        perc_completed(pkt.perc_completed){}

    /*
     * Depending on the analysis type NgSpice can return a number of
     * complex vectors, each one having it's own unique name.
     */
    std::map<std::string,std::vector<std::complex<double>>> vectors;

    /*
     * Computation statistics (the getstat_cb callback) is almost always a computation
     * percentage. Each time we get a statistical report, we try to parse out the
     * completeness of the current computation in percents and if it is possible -
     * we store the result inside of this variable.
     */
    float perc_completed = 0;
};

struct InitData {
    std::string name;
    std::string title;
    std::string date;
    std::string type;
    std::vector<std::string> vectors;
};


class NgSpiceSRC : public BaseSource<NgSpiceOutPkt>{
public:
    using tBase = BaseSource<NgSpiceOutPkt>;
    using tPtrOut = typename tBase::tPtrOut;

    NgSpiceSRC(std::string cir_file  = std::string(), int slice_data = -1);
    ~NgSpiceSRC();

// NgSpice callback functions. The void* userdata always points onto the
// instance of the current object.
protected:
    /*
     * callback function for reading printf, fprintf, fput (NULL allowed)
     */
    static int getchar_cb(char* outputreturn, int ident, void* userdata);

    /*
     * callback function for reading status string and percent value (NULL allowed)
     */
    static int getstat_cb(char* outputreturn, int ident, void* userdata);

    /*
     * callback function for sending an array of structs containing data values of all
     * vectors in the current plot (simulation output) (NULL allowed)
     */
    static int data_cb(pvecvaluesall vdata, int numvecs, int ident, void* userdata);

    /*
     * callback function for sending an array of structs containing info on all vectors in the
     * current "plot" (immediately before simulation starts) (NULL allowed)
     *
     * This function is called each time the simulation starts from the beginning. If we
     * "bg_halt" the simulation and call "bg_run" afterwards - thsi function will be called
     * for the second time.
     */
    static int initdata_cb(pvecinfoall intdata, int ident, void* userdata);

    /*
     * Callback function for sending a boolean signal (true if computational thread is running)(NULL allowed)
     *
     * This function is called each time the computation start or resume it's work.
     */
    static int simulation_runs_cb(bool not_running, int ident, void* userdata);

    /*
     * Callback function for transferring a flag to caller, generated by ngspice
     * upon a call to function controlled_exit. (required) The controlled exit can be
     * initiated by the next calls:
     *
     * ngSpice_Command((char*) "bg_halt"); -- switch to command mode
     * ngSpice_Command((char*) "quit"); -- quit the procss
     *
     * After "quit" command the circuit is unloaded and ngspice thread stops. All the memory
     * will be freed. After this command, the ngspice can be completely reinitialize
     * by ngSpice_Init(...) and subsequent calls.
     *
     * => Use "quit" in the source destructor.
     * => Use exit_cb callback to set ng_alive = false;
     */
    static int exit_cb(int exitstatus, bool immediate, bool quitexit, int ident, void* userdata);

    // Some internal routines
private:
    void send_out_message();

private:
    /*
     * State variables of the NgSpice simulation process
     */
    std::atomic<bool> is_loaded;
    std::atomic<bool> is_halted;

    /*
     * Current circuit file. This file can be nempty if you prefer to load
     * circuit dynamically with the help of ngSpice_Circ(...) function.
     */
    std::string cir_file;

    /*
     * There are two basic modes to work with NgSpice. For example you can initiate a
     * very long (2h or more) transient simulation with typical dt ~ 5us and slice output data
     * into the outgoing packets por N points each. That is a classical oscilloscope mode.
     *
     * Another way, is to send an outgoing packet when a computation is done. In this case
     * the data is not sliced and slice_data should be less or equel to zero. A typical
     * example is an AC simulation.
     */
    int slice_data;

    /*
     * An output message is prepared by NgSpice callbacks. When it is ready - it will be sent,
     * and at the same time a new empty instance of the output pkt will be created. This
     * is the law - out_msg is never nullptr! It is a buffer!
     */
    tPtrOut out_msg;

    /*
     * Reading or writing of not atomic members of this class from NgSpice callbacks or
     * from the user messages should be always protected by this mutex.
     */
    std::mutex comp_state_mtx;

    /*
     * When new circuit loads, it fills out some information about itself computation.
     * This data can be useful for the other nodes, for example for the user view.
     * It can be retrieved via the user message with callback technique.
     */
    InitData init_data;
};

#endif //DISTPIPELINEFWK_NGSPICE_SRC_H
